带dbscan结尾的，是先对原始flow根据五元组合并成channel
 - 然后根据{Stream_duration,pkt_number,total_data_length,up_length,down_length}五个特征进行预聚类
 - 然后剃除了聚类内部不属于众数标签的channel(论文是认为，通过控制聚类的eps参数可以做到聚类内部只包含一种label的channel)，然后对聚类内部的channel的特征序列进行合并，具体就是首尾相连，构成behavior_sequence
 - 然后对四个behavior_sequence分别训练词嵌入模型，把对应的数值根据出现次数映射到词向量（是怎么用词嵌入来确保80和8080之间的相关性的，根据出现频率吗，分别训练就无法通过其他维度特征的关系来推导本维度的关系）
 - 最后把词嵌入表示的向量作为一类channel，也就是一个cluster的特征表示，输入到分类器

用全样本训练80轮再试一次。对dbscan的开销太大，不可行

5.23，发现dbscan是对vpn和非vpn分别做的，显然不合理，应该一起做预聚类，修改cluster逻辑，所有数据合并之后再做聚类。
打印了dbscan的聚类结果和准确率之后，确定dbscan是没有问题的，效果很好。那如果还训练不出，就只能是词嵌入没表示对或网络问题



上午：修改了注意力机制，用了多头注意力机制层，WKV全用的是x本身。但是代码没改过来，导致代码运行时，使用的还是没有正则化和线性变换之前的，注意力机制的原始输出。

下午：修改了FNN前馈网络的W和B，从空值开始而不是随机数，这样初始损失就不会太大了。仔细看了一下，每一个encoder block的FNN和没有用到的FeedForward其实是同一个逻辑，都是线性变化层。

晚上：看了Rosetta的Transformer代码，发现他的实现细节其实就是transformer的。
再晚上，讨论得出，对于输入格式（维度、数值范围）相同的序列，只需要一个encoder就可以解决

论文创新点：发现了一个大前提：通过一组特征，可以实现样本的预聚类，每个聚类内部的样本都属于同一个大类别。
这样就可以用小聚类作为样本的单元来代替原来的flow和channel，对cluster的channel样本进行编码，输入到分类模型，最后用cluster的分类结果反推给其中的每一个flow即可。
重点就是样本粒度转换的前提：一个channel的flow，一个cluster的channel一定是同一个类的，才能在后面匪类任务的时候，用其他特征做分类。


设计一个，针对VPN分类任务单独处理过的模型，即有哪些模块是这个模型针对VPN专门修改过的。或者从别的二分类任务借鉴，然后改成VPN专门处理的，就可以写论文了。

5.24,修改两处逻辑
 - 对于dbscan，论文说了对于无法聚类的channel单独划分一个cluster，这样才能充分利用每个样本。
      - 目前采取的是，读取数据时剃除聚类的噪声类。
 - 对于Dataset构建，读取的单元是每个聚类对应的behavior sequence，因此重写，每次读取的不是channel而是cluster。这样就会导致模型输入不对齐，因此需要指定每个behavior sequence的每个特征的长度为16。

 - 修改之后，模型准确率终于达到了70.至少说明模型是对的了，10000也让大部分类所有数据都用上，但还有得类只有十几个样本，因此仍然是不均匀。准确率低的原因可能是丢掉了所有的噪声类样本，尝试把噪声类的每个样本都当成一个单独聚类，扩充训练样本数量，以此提高准确性。
 
 1.MSFormer,不使用dbscan聚类，直接对所有的channel做分类
 2.MSFormer_dbscan，dbscan的噪声点全都丢弃处理，分别用1000和10000的采样规模，准确率分别是47和70。


 
 3.MSFormer_dbscan_channel，用了dbscan，但是模型的dataloader输入是一个cluster的一个channel对应的词嵌入向量
 相当于只用到了cluster的某1个channel的信息，聚类信息利用率低，准确率在6-20之间。



 4.MSFormer_dbscan_all_noise，一个噪声一个独立的cluster,把之前方法丢弃的噪声点补充到实验数据中，模型输入仍然是cluster对应的embeded behavior sequence。分别用1000和10000的采样规模，准确率分别是67和72。